## Imperator extensions

This gem includes some extensions and integrtions for the [imperator](https://github.com/Agowan/imperator) gem.

The integrations are for:

* [focused controller](https://github.com/jonleighton/focused_controller)
* [mongoid](https://github.com/mongoid/mongoid)

The Mongoid integration provides the class method `attributes_for`, 
which can be used to define Command attributes that match the fields of the Mongoid object that the command is designed to operate on.

```ruby
  attributes_for Post, only: [:subject, :body]
```

```ruby
  attributes_for Post, except: [:state]
```

In addition this gem extends the `Imperator::Command` with the attributes 
`object` and `initiator`.

## Controllers, Actions and Commands

An analysis of the current MVC design pattern in Rails, in particular how the Controllers
are designed and can be improved by employing different Design Patterns to ensure better
decoupling, single responsibility and how to aovid the typical Rails anti-pattern of flat classes, bloated with methods.

## Using Imperator Commands in the current Controller pattern

Demonstrates just how ugly the current Controller convention is!!!

```ruby
class PostController < ApplicationController
  def update    
    update_command.valid? ? update_valid : update_invalid
  end

  protected

  def update_valid
    update_command.perform and redirect_to(root_url)
  end

  def update_invalid
    render edit_post_path(command.object)
  end

  def update_command
    @update_command ||= UpdatePostCommand.new(params[:post])
  end
end
```

## Using Imperator Commands with Focused Controllers

Much nicer encapsulated logic using FocusedController :)

```ruby
module PostController
  class Update < UpdateCommandAction
    invalid_path do
      root_url
    end

    # generated by naming convention
    # command { @command ||= UpdatePostCommand.new post_hash }
  end
end
```

Demonstrating some customization of Controller logic

```ruby
module PostController
  class Update < UpdateCommandAction
    valid do
      command.perform
      redirect_to root_url
    end

    def invalid
      flash_msg "#{command.object} was invalid!", :error
      super
    end

    command { @command ||= command_class.new object_hash.merge(:status => :complete) }
  end
end
```

And more...

```ruby
module PostController
  class Update < UpdateCommandAction
    valid do
      flash_msg "#{command.object} was valid!"
      command.perform
      puts "#{command} was performed!"
      valid_redirect
    end

    valid_redirect_path do
      root_url
    end

    def invalid
      flash_msg "#{command.object} was invalid!", :error
      super
    end

    command do
      @command ||= begin
        c = UpdatePostCommand.new post_hash
        c.complete_it!
      end
    end
  end
end
```

## Rest Commands

If you inherit from the `Imperator::Command::Rest` class, you gain access to the
REST convenience methods: `update`, `delete` and `create_new` which creates action methods with some default appropriate REST logic for the particular action.
See the code for more info on how to use this for your own needs.

```ruby
class UpdatePostCommand < Imperator::Command::Rest
  attribute :some_object_id
  attribute :some_value

  validates_presence_of :some_object_id

  update do
    puts "updated OK"
  end
end
```

## Mongoid integration

Imperator also comes with a little Mongodi adaptor class, which provides the `attributes_for` method in order to easily redefine Mongoid model fields as Command attributes. Similar adaptors could be created for other ORMs such as Active Record etc.

```ruby
class UpdatePostCommand < Imperator::Mongoid::Command::Rest

  attributes_for Post, except: [:status, :rating]

  validates :name, presence: true

  update do    
    puts "#{object} was updated"
  end

  on_error do
    puts "The Post could not be updated: #{object}"
  end
end
```

## Class Factory

The `Imperator::Command::ClassFactory` can be used to easily create Command wrappers for your model classes.

```ruby
Imperator::Command::ClassFactory.create :publish, Post do
  action do
    find_object.publish!
  end
end
```

It is especially handy for creating Rest Command wrappers.

```ruby
require 'imperator/command/macros'

imperator_command_factory.use do |factory|
  # put common/shared logic in this REST base class
  factory.default_rest_class = Imperator::Mongoid::Command::Rest

  factory.create_rest :all, Post do
    on_error do
      puts "Oops! There was an error!"
    end
  end

  factory.create_rest :update, Article do
    attributes_for Article, only: [:title, :body] 

    on_error do
      puts "Oops! There was an error!"
    end
  end

  # Same using :auto_attributes option
  factory.create_rest :update, Article, auto_attributes: true, except: [:status] do
    on_error do
      puts "Oops! There was an error!"
    end
  end
end
```

## Using ClassFactory macros

There are also two global macros `create_command` and `create_rest_command` available.

```ruby
# ensure all attributes of model are reflected in Command (if adaptor makes it possible)
Imperator::Command::ClassFactory.default_options = {auto_attributes: true}

module PostController
  class Update < UpdateCommandAction

    command do
      @command ||= create_rest_command(:update, Post).new object_hash
    end
  end
end
```

## Contributing to imperator-ext
 
* Check out the latest master to make sure the feature hasn't been implemented or the bug hasn't been fixed yet.
* Check out the issue tracker to make sure someone already hasn't requested it and/or contributed it.
* Fork the project.
* Start a feature/bugfix branch.
* Commit and push until you are happy with your contribution.
* Make sure to add tests for it. This is important so I don't break it in a future version unintentionally.
* Please try not to mess with the Rakefile, version, or history. If you want to have your own version, or is otherwise necessary, that is fine, but please isolate to its own commit so I can cherry-pick around it.

## Copyright

Copyright (c) 2012 Kristian Mandrup. See LICENSE.txt for
further details.

